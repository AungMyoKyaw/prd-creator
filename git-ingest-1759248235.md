# 🚀 Project Analysis Report

Directory structure for: prd-creator-2

## 🎯 LLM-Optimized Codebase Analysis

This document provides a comprehensive, structured analysis of the codebase optimized for 
Large Language Model (LLM) processing. The content is organized with semantic markup, 
proper syntax highlighting, and hierarchical structure for enhanced AI comprehension.

## 📑 Table of Contents

- [📊 Project Overview](#-project-overview)
- [📈 Statistics](#-statistics)
- [🏗️ Directory Structure](#️-directory-structure)
- [📁 Files by Category](#-files-by-category)
  - [🌐 Web Frontend](#1f310-web-frontend)
  - [⚙️ Data/Config](#2699-data-config)
  - [📖 Documentation](#1f4d6-documentation)
- [📋 Complete File Listing](#-complete-file-listing)

## 📊 Project Overview

**Project:** `prd-creator-2`  
**Path:** `/Users/aungmyokyaw/Downloads/prd-creator-2`  
**Generated:** 2025-09-30T16:03:55.130Z  
**Total Files:** 21  
**Total Size:** 46.1 KB  

### 🎯 Quick Summary

This document contains a comprehensive analysis of the **prd-creator-2** project, 
including its complete directory structure and the full content of all text files. 
The content is organized in a hierarchical, LLM-friendly format with proper syntax 
highlighting and metadata for optimal AI processing.

## 📈 Statistics

### 📊 File Type Distribution

| Category | Files | Percentage |
| --- | --- | --- |
| Web Frontend | 17 | 81.0% |
| Data/Config | 3 | 14.3% |
| Documentation | 1 | 4.8% |

### 💻 Programming Languages

| Language | Files | Primary Category |
| --- | --- | --- |
| tsx | 13 | Web Frontend |
| json | 3 | Data/Config |
| typescript | 3 | Web Frontend |
| markdown | 1 | Documentation |
| html | 1 | Web Frontend |

### 📏 Size Analysis

- **Total Project Size:** 46.1 KB
- **Average File Size:** 2.2 KB
- **Text Files:** 21 (100.0%)

## 🏗️ Directory Structure

```
├── components
│   ├── Button.tsx
│   ├── Footer.tsx
│   ├── Header.tsx
│   ├── InputField.tsx
│   ├── Loader.tsx
│   ├── MarkdownRenderer.tsx
│   ├── PRDDisplay.tsx
│   ├── PRDForm.tsx
│   ├── RefineModal.tsx
│   ├── Section.tsx
│   └── TextareaField.tsx
├── services
│   └── geminiService.ts
├── App.tsx
├── index.html
├── index.tsx
├── metadata.json
├── package.json
├── README.md
├── tsconfig.json
├── types.ts
└── vite.config.ts
```

## 📁 Files by Category

### 🌐 Web Frontend

**Languages:** tsx, html, typescript  
**File Count:** 17

### ⚙️ Data/Config

**Languages:** json  
**File Count:** 3

### 📖 Documentation

**Languages:** markdown  
**File Count:** 1
## 📋 Complete File Listing

The following section contains the complete content of all text files in the project, 
organized with proper syntax highlighting and metadata for optimal LLM processing.

### 📄 `App.tsx`

**Path:** `App.tsx`  
**Size:** 9.9 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';
import { useState, useEffect } from 'react';
import type { PRDInput } from './types';
import Header from './components/Header';
import Footer from './components/Footer';
import PRDForm from './components/PRDForm';
import PRDDisplay from './components/PRDDisplay';
import Loader from './components/Loader';
import { generatePRD, generatePRDInputs, refinePRDSection } from './services/geminiService';
import TextareaField from './components/TextareaField';
import Button from './components/Button';
import RefineModal from './components/RefineModal';

// FIX: Removed React.FC type for better type inference and to resolve a potential issue where the component was incorrectly inferred as returning void.
const App = () => {
  const [productIdea, setProductIdea] = useState<string>('');
  const [isPrefilling, setIsPrefilling] = useState<boolean>(false);
  const [prefillError, setPrefillError] = useState<string>('');

  const [prdInput, setPrdInput] = useState<PRDInput>({
    productName: '',
    targetAudience: '',
    problemStatement: '',
    proposedSolution: '',
    coreFeatures: '',
    businessGoals: '',
    futureFeatures: '',
    techStack: '',
    constraints: '',
  });

  const [generatedPrd, setGeneratedPrd] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [livePreviewContent, setLivePreviewContent] = useState<string>('');

  // State for the refinement modal
  const [refiningSection, setRefiningSection] = useState<string | null>(null);
  const [refineFeedback, setRefineFeedback] = useState('');
  const [isRefining, setIsRefining] = useState(false);
  const [refineError, setRefineError] = useState('');


  const generatePreviewMarkdown = (inputs: PRDInput): string => {
    return `
# ${inputs.productName || 'Product Name...'}

---

### 1. Introduction & Vision

**1.1. Problem Statement**
*The core problem this product solves is:*
${inputs.problemStatement || '...'}

**1.2. Proposed Solution**
*Our proposed solution is:*
${inputs.proposedSolution || '...'}

**1.3. Vision**
*[AI will generate a compelling long-term vision for this product based on the problem and solution.]*

---

### 2. Target Audience & User Personas

**2.1. Primary Audience**
*The primary users for this product are:*
${inputs.targetAudience || '...'}

**2.2. User Personas**
*[AI will generate 2-3 brief but distinct user personas based on the target audience.]*

---

### 3. Product Goals & Success Metrics

**3.1. Business Goals**
*The key business objectives for this product are:*
${inputs.businessGoals || '...'}

**3.2. Success Metrics (KPIs)**
*[AI will generate specific, measurable, achievable, relevant, and time-bound (SMART) KPIs based on the business goals.]*

---

### 4. Features & Requirements

**4.1. Core Features (MVP)**
*The essential features for the Minimum Viable Product are:*
${inputs.coreFeatures || '- ...'}

**4.2. User Stories**
*[AI will write 2-3 detailed user stories for each core feature.]*

**4.3. Future Features (Post-MVP)**
*Potential features for future releases include:*
${inputs.futureFeatures || '- ...'}

---

### 5. Technical Considerations & Constraints

**5.1. Technology Stack**
*The proposed or existing technology stack is:*
${inputs.techStack || '...'}

**5.2. Constraints & Dependencies**
*Known limitations and dependencies are:*
${inputs.constraints || '...'}

---

### 6. Out of Scope

*[AI will define what will NOT be included in the initial release to manage expectations.]*
  `;
  };

  useEffect(() => {
    setLivePreviewContent(generatePreviewMarkdown(prdInput));
  }, [prdInput]);

  const handlePrefillForm = async () => {
    if (!productIdea.trim()) return;
    setPrefillError('');
    setIsPrefilling(true);
    try {
      const prefilledData = await generatePRDInputs(productIdea);
      setPrdInput(prefilledData);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setPrefillError(errorMessage);
    } finally {
      setIsPrefilling(false);
    }
  };

  // FIX: The following event handlers were likely defined outside the component scope in the problematic code, causing numerous "Cannot find name" errors. They are now correctly defined within the App component.
  const handleGeneratePrd = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setGeneratedPrd('');
    setIsLoading(true);

    try {
      const result = await generatePRD(prdInput);
      setGeneratedPrd(result);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setError(`Failed to generate PRD: ${errorMessage}`);
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleOpenRefineModal = (sectionTitle: string) => {
    setRefiningSection(sectionTitle);
    setRefineFeedback('');
    setRefineError('');
  };

  const handleCloseRefineModal = () => {
    if (isRefining) return;
    setRefiningSection(null);
  };

  const handleRefineSubmit = async () => {
    if (!refiningSection || !refineFeedback.trim()) return;
    setIsRefining(true);
    setRefineError('');
    try {
      const updatedData = await refinePRDSection(prdInput, refiningSection, refineFeedback);
      setPrdInput(prev => ({ ...prev, ...updatedData }));
      handleCloseRefineModal();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setRefineError(errorMessage);
    } finally {
      setIsRefining(false);
    }
  };

  return (
    <div className="min-h-screen bg-slate-900 text-white font-sans flex flex-col">
      <div className="flex-grow">
        <main className="container mx-auto px-4 sm:px-6 lg:px-8">
          <Header />
          <div className="flex flex-col lg:flex-row lg:gap-12">
            
            {/* Left Column: Form */}
            <div className="lg:w-1/2 w-full">
              <div className="bg-slate-800/20 p-8 rounded-xl shadow-2xl border border-slate-700">
                <h2 className="text-2xl font-bold text-white mb-1">Step 1: Start with an Idea</h2>
                <p className="text-slate-400 mb-6">Describe your product idea, and let AI help you flesh out the details.</p>
                <div className="space-y-4">
                  <TextareaField
                      label="Your Product Idea"
                      id="productIdea"
                      name="productIdea"
                      value={productIdea}
                      onChange={(e) => setProductIdea(e.target.value)}
                      placeholder="e.g., An app that uses a phone's camera to identify plants and give care instructions."
                      rows={3}
                      required
                  />
                  <Button onClick={handlePrefillForm} isLoading={isPrefilling} disabled={!productIdea.trim() || isPrefilling}>
                      {isPrefilling ? 'Brainstorming...' : 'Flesh out my idea'}
                  </Button>
                </div>
                {prefillError && (
                  <div className="mt-4 bg-red-900/50 border border-red-700 text-red-300 p-3 rounded-lg text-sm">
                    <p><span className="font-bold">Error:</span> {prefillError}</p>
                  </div>
                )}
              </div>

              <div className="relative my-10">
                <div className="absolute inset-0 flex items-center" aria-hidden="true">
                  <div className="w-full border-t border-slate-700"></div>
                </div>
                <div className="relative flex justify-center">
                  <span className="bg-slate-900 px-3 text-base font-medium text-slate-400">Step 2: Refine & Generate</span>
                </div>
              </div>

              <div className="bg-slate-800/20 p-8 rounded-xl shadow-2xl border border-slate-700">
                <PRDForm
                  prdInput={prdInput}
                  setPrdInput={setPrdInput}
                  onSubmit={handleGeneratePrd}
                  isLoading={isLoading}
                  onRefineSection={handleOpenRefineModal}
                />
              </div>
              
              {/* Mobile/stacked view for results */}
              <div className="lg:hidden mt-8">
                {isLoading && <Loader />}
                
                {error && (
                  <div className="mt-8 bg-red-900/50 border border-red-700 text-red-300 p-4 rounded-lg">
                    <p className="font-bold">Error</p>
                    <p>{error}</p>
                  </div>
                )}

                {generatedPrd && !isLoading && <PRDDisplay content={generatedPrd} />}
              </div>
            </div>

            {/* Right Column: Preview Pane */}
            <div className="lg:w-1/2 w-full hidden lg:block">
               <div className="lg:sticky lg:top-0 lg:max-h-screen lg:overflow-y-auto py-6">
                 {isLoading ? (
                    <div className="flex items-center justify-center h-full"><Loader /></div>
                 ) : (
                    <PRDDisplay 
                      content={generatedPrd || livePreviewContent} 
                      isLivePreview={!generatedPrd} 
                    />
                 )}
                 {error && (
                    <div className="mt-8 bg-red-900/50 border border-red-700 text-red-300 p-4 rounded-lg">
                      <p className="font-bold">Error</p>
                      <p>{error}</p>
                    </div>
                  )}
               </div>
            </div>

          </div>
        </main>
      </div>
      <Footer />
      {refiningSection && (
         <RefineModal
          isOpen={!!refiningSection}
          onClose={handleCloseRefineModal}
          onSubmit={handleRefineSubmit}
          isLoading={isRefining}
          sectionTitle={refiningSection}
          feedback={refineFeedback}
          setFeedback={setRefineFeedback}
          error={refineError}
        />
      )}
    </div>
  );
};

export default App;
```

### 📄 `README.md`

**Path:** `README.md`  
**Size:** 553 B  
**Language:** markdown (medium confidence)  
**Category:** Documentation  
```markdown
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/1Xegz-MGWv8cZoWYfyTRQG6sOzZMFayAi

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`
```

### 📄 `Button.tsx`

**Path:** `components/Button.tsx`  
**Size:** 1.4 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  isLoading?: boolean;
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({ isLoading = false, children, ...props }) => {
  return (
    <button
      className="relative w-full inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 focus:ring-indigo-500 disabled:bg-indigo-400 disabled:cursor-not-allowed transition-colors duration-200 ease-in-out"
      disabled={isLoading}
      {...props}
    >
      {isLoading && (
        <svg
          className="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          ></circle>
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          ></path>
        </svg>
      )}
      <span>{isLoading ? 'Generating...' : children}</span>
    </button>
  );
};

export default Button;
```

### 📄 `Footer.tsx`

**Path:** `components/Footer.tsx`  
**Size:** 280 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer className="py-6 text-center">
      <p className="text-sm text-slate-500">
        Powered by Gemini API. Built for modern product teams.
      </p>
    </footer>
  );
};

export default Footer;
```

### 📄 `Header.tsx`

**Path:** `components/Header.tsx`  
**Size:** 595 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

const Header: React.FC = () => {
  return (
    <header className="py-6">
      <div className="text-center">
        <h1 className="text-4xl font-extrabold text-white sm:text-5xl md:text-6xl tracking-tight">
          <span className="text-indigo-400">AI</span> PRD Creator 📝
        </h1>
        <p className="mt-3 max-w-md mx-auto text-base text-slate-400 sm:text-lg md:mt-5 md:text-xl md:max-w-3xl">
          Turn your ideas into professional Product Requirements Documents instantly.
        </p>
      </div>
    </header>
  );
};

export default Header;
```

### 📄 `InputField.tsx`

**Path:** `components/InputField.tsx`  
**Size:** 685 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

interface InputFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label: string;
  id: string;
}

const InputField: React.FC<InputFieldProps> = ({ label, id, ...props }) => {
  return (
    <div>
      <label htmlFor={id} className="block text-sm font-medium text-slate-300 mb-1">
        {label}
      </label>
      <input
        id={id}
        className="block w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded-md text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition"
        {...props}
      />
    </div>
  );
};

export default InputField;
```

### 📄 `Loader.tsx`

**Path:** `components/Loader.tsx`  
**Size:** 998 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

const Loader: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center p-8 bg-slate-800 rounded-lg border border-slate-700 mt-8">
      <svg
        className="animate-spin h-10 w-10 text-indigo-400"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        ></circle>
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>
      <p className="mt-4 text-lg font-medium text-slate-300">Generating your PRD...</p>
      <p className="text-sm text-slate-500">The AI is thinking. This may take a moment.</p>
    </div>
  );
};

export default Loader;
```

### 📄 `MarkdownRenderer.tsx`

**Path:** `components/MarkdownRenderer.tsx`  
**Size:** 2.2 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React, { ReactNode } from 'react';

// A simple function to apply inline formatting like bold and italic.
// It splits the string by the formatting characters to avoid complex regex.
const applyInlineFormatting = (text: string): ReactNode => {
    // Regex to split by **word** or *word*, keeping the delimiters
    const parts = text.split(/(\*\*.*?\*\*|\*.*?\*)/g);
    return parts.map((part, i) => {
        if (part.startsWith('**') && part.endsWith('**')) {
            return <strong key={i}>{part.slice(2, -2)}</strong>;
        }
        if (part.startsWith('*') && part.endsWith('*')) {
            return <em key={i}>{part.slice(1, -1)}</em>;
        }
        return part;
    });
};

const MarkdownRenderer: React.FC<{ content: string }> = ({ content }) => {
  const lines = content.split('\n');
  const blocks: ReactNode[] = [];
  let currentList: ReactNode[] = [];

  const flushList = () => {
    if (currentList.length > 0) {
      blocks.push(<ul key={`ul-${blocks.length}`}>{currentList}</ul>);
      currentList = [];
    }
  };

  lines.forEach((line, index) => {
    const isListItem = line.trim().startsWith('* ') || line.trim().startsWith('- ');
    
    // If the line is not a list item, but we were in a list, close the list.
    if (!isListItem) {
      flushList();
    }

    if (line.startsWith('# ')) {
      blocks.push(<h1 key={index}>{applyInlineFormatting(line.substring(2))}</h1>);
    } else if (line.startsWith('## ')) {
        blocks.push(<h2 key={index}>{applyInlineFormatting(line.substring(3))}</h2>);
    } else if (line.startsWith('### ')) {
      blocks.push(<h3 key={index}>{applyInlineFormatting(line.substring(4))}</h3>);
    } else if (line.match(/^---\s*$/)) {
      blocks.push(<hr key={index} />);
    } else if (isListItem) {
      currentList.push(<li key={index}>{applyInlineFormatting(line.trim().substring(2))}</li>);
    } else if (line.trim() !== '') {
      blocks.push(<p key={index}>{applyInlineFormatting(line)}</p>);
    }
    // Ignore empty lines for block creation, but they can act as list separators.
  });

  flushList(); // Flush any remaining list at the end of the document

  return <>{blocks}</>;
};

export default MarkdownRenderer;
```

### 📄 `PRDDisplay.tsx`

**Path:** `components/PRDDisplay.tsx`  
**Size:** 3.1 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React, { useState, useEffect } from 'react';
import MarkdownRenderer from './MarkdownRenderer';

interface PRDDisplayProps {
  content: string;
  isLivePreview?: boolean;
}

const CopyIcon: React.FC<{className?: string}> = ({className}) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className || "w-6 h-6"}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" />
    </svg>
);

const CheckIcon: React.FC<{className?: string}> = ({className}) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className || "w-6 h-6"}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

const PRDDisplay: React.FC<PRDDisplayProps> = ({ content, isLivePreview = false }) => {
  const [isCopied, setIsCopied] = useState(false);

  useEffect(() => {
    if (isCopied) {
      const timer = setTimeout(() => {
        setIsCopied(false);
      }, 2000);
      return () => clearTimeout(timer);
    }
  }, [isCopied]);

  const handleCopy = () => {
    // A simple regex to strip markdown for plain text copy
    const plainText = content
      .replace(/###\s/g, '')
      .replace(/##\s/g, '')
      .replace(/#\s/g, '')
      .replace(/\*\*/g, '')
      .replace(/\*/g, '')
      .replace(/---\s/g, '\n')
      .replace(/-\s/g, '');

    navigator.clipboard.writeText(plainText);
    setIsCopied(true);
  };

  return (
    <div className="bg-slate-800/50 rounded-lg border border-slate-700 shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-slate-600">
        <h2 className="text-xl font-semibold text-white">{isLivePreview ? 'Live Preview' : 'Generated PRD'}</h2>
        {!isLivePreview && (
          <button
            onClick={handleCopy}
            className="flex items-center px-3 py-1.5 text-sm font-medium text-slate-300 bg-slate-700 hover:bg-slate-600 rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800 focus:ring-indigo-500"
          >
            {isCopied ? (
              <>
                <CheckIcon className="w-4 h-4 mr-2 text-green-400"/>
                Copied!
              </>
            ) : (
              <>
                <CopyIcon className="w-4 h-4 mr-2"/>
                Copy
              </>
            )}
          </button>
        )}
      </div>
      <div className="p-6">
        <div className="markdown-content text-slate-300">
            <MarkdownRenderer content={content} />
        </div>
      </div>
    </div>
  );
};

export default PRDDisplay;
```

### 📄 `PRDForm.tsx`

**Path:** `components/PRDForm.tsx`  
**Size:** 4.9 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';
import type { PRDInput } from '../types';
import InputField from './InputField';
import TextareaField from './TextareaField';
import Button from './Button';
import Section from './Section';

interface PRDFormProps {
  prdInput: PRDInput;
  setPrdInput: React.Dispatch<React.SetStateAction<PRDInput>>;
  onSubmit: (e: React.FormEvent) => void;
  isLoading: boolean;
  onRefineSection: (sectionTitle: string) => void;
}

const PRDForm: React.FC<PRDFormProps> = ({ prdInput, setPrdInput, onSubmit, isLoading, onRefineSection }) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setPrdInput(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form onSubmit={onSubmit} className="space-y-6">
      <Section title="1. Core Product Idea" onRefine={() => onRefineSection('1. Core Product Idea')}>
        <InputField
          label="Product Name"
          id="productName"
          name="productName"
          value={prdInput.productName}
          onChange={handleChange}
          placeholder="e.g., Apollo - The AI Trip Planner"
          required
        />
        <TextareaField
          label="Problem Statement"
          id="problemStatement"
          name="problemStatement"
          value={prdInput.problemStatement}
          onChange={handleChange}
          description="What specific problem is this product trying to solve for its users?"
          placeholder="e.g., Planning a group trip is chaotic and time-consuming..."
          required
        />
        <TextareaField
          label="Proposed Solution"
          id="proposedSolution"
          name="proposedSolution"
          value={prdInput.proposedSolution}
          onChange={handleChange}
          description="Briefly describe how your product solves this problem."
          placeholder="e.g., A mobile app that centralizes itineraries, budgets, and communication..."
          required
        />
      </Section>
      
      <Section title="2. Audience & Market" onRefine={() => onRefineSection('2. Audience & Market')}>
        <TextareaField
          label="Target Audience"
          id="targetAudience"
          name="targetAudience"
          value={prdInput.targetAudience}
          onChange={handleChange}
          description="Who are the primary users of this product? Be specific."
          placeholder="e.g., Tech-savvy millennials aged 25-40 who frequently travel in groups..."
          required
        />
         <TextareaField
          label="Business Goals & Success Metrics"
          id="businessGoals"
          name="businessGoals"
          value={prdInput.businessGoals}
          onChange={handleChange}
          description="What are the key business objectives and how will you measure success (KPIs)?"
          placeholder="e.g., Goal: Achieve 10,000 monthly active users in 6 months. KPI: User retention rate > 30%..."
        />
      </Section>
      
      <Section title="3. Features & Scope" onRefine={() => onRefineSection('3. Features & Scope')}>
        <TextareaField
          label="Core Features (MVP)"
          id="coreFeatures"
          name="coreFeatures"
          value={prdInput.coreFeatures}
          onChange={handleChange}
          description="List the absolute essential features for the first version. Use bullet points or numbered lists."
          placeholder="- Collaborative Itinerary Planning\n- Shared Expense Tracking\n- Group Chat"
          required
        />
         <TextareaField
          label="Future Features (Post-MVP)"
          id="futureFeatures"
          name="futureFeatures"
          value={prdInput.futureFeatures}
          onChange={handleChange}
          description="What are some potential features for future releases?"
          placeholder="- Booking integrations (flights, hotels)\n- AI-powered recommendations\n- Offline mode"
        />
      </Section>
      
      <Section title="4. Technical Details (Optional)" onRefine={() => onRefineSection('4. Technical Details (Optional)')}>
         <InputField
          label="Technology Stack"
          id="techStack"
          name="techStack"
          value={prdInput.techStack}
          onChange={handleChange}
          placeholder="e.g., React Native, Firebase, Node.js"
        />
         <TextareaField
          label="Constraints & Dependencies"
          id="constraints"
          name="constraints"
          value={prdInput.constraints}
          onChange={handleChange}
          description="Are there any known technical limitations, budget constraints, or dependencies?"
          placeholder="e.g., Must integrate with Stripe API for payments. Budget is limited to $50k for MVP."
        />
      </Section>
      
      <div className="pt-4">
        <Button type="submit" isLoading={isLoading}>
          Generate PRD
        </Button>
      </div>
    </form>
  );
};

export default PRDForm;
```

### 📄 `RefineModal.tsx`

**Path:** `components/RefineModal.tsx`  
**Size:** 4.4 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';
import Button from './Button';
import TextareaField from './TextareaField';

interface RefineModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: () => void;
  isLoading: boolean;
  sectionTitle: string;
  feedback: string;
  setFeedback: (value: string) => void;
  error?: string;
}

const RefineModal: React.FC<RefineModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  isLoading,
  sectionTitle,
  feedback,
  setFeedback,
  error,
}) => {
  if (!isOpen) return null;

  return (
    <div
      className="relative z-10"
      aria-labelledby="modal-title"
      role="dialog"
      aria-modal="true"
    >
      <div className="fixed inset-0 bg-slate-900/80 backdrop-blur-sm transition-opacity"></div>
      <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
        <div className="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0">
          <div className="relative transform overflow-hidden rounded-lg bg-slate-800 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg border border-slate-700">
            <div className="bg-slate-800 px-4 pb-4 pt-5 sm:p-6 sm:pb-4">
              <div className="sm:flex sm:items-start">
                <div className="mx-auto flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-indigo-900/50 sm:mx-0 sm:h-10 sm:w-10">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6 text-indigo-400">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.572L16.5 21.75l-.398-1.178a3.375 3.375 0 00-2.455-2.456L12.75 18l1.178-.398a3.375 3.375 0 002.455-2.456L16.5 14.25l.398 1.178a3.375 3.375 0 002.456 2.456L20.25 18l-1.178.398a3.375 3.375 0 00-2.456 2.456z" />
                  </svg>
                </div>
                <div className="mt-3 text-center sm:ml-4 sm:mt-0 sm:text-left w-full">
                  <h3 className="text-base font-semibold leading-6 text-white" id="modal-title">
                    Refine "{sectionTitle}"
                  </h3>
                  <div className="mt-4 w-full">
                     <TextareaField
                        label="Your Feedback"
                        id="refineFeedback"
                        value={feedback}
                        onChange={(e) => setFeedback(e.target.value)}
                        placeholder={`e.g., "Make the tone more formal" or "Add a feature for social media sharing."`}
                        rows={4}
                        description="Provide instructions for the AI to edit this section."
                     />
                  </div>
                   {error && (
                    <div className="mt-3 bg-red-900/50 border border-red-700 text-red-300 p-3 rounded-lg text-sm">
                      <p><span className="font-bold">Error:</span> {error}</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
            <div className="bg-slate-800/50 px-4 py-3 sm:flex sm:flex-row-reverse sm:px-6">
              <div className="sm:w-1/2 sm:pl-2">
                <Button
                    type="button"
                    onClick={onSubmit}
                    isLoading={isLoading}
                    disabled={isLoading || !feedback.trim()}
                >
                    {isLoading ? 'Refining...' : 'Refine with AI'}
                </Button>
              </div>
              <div className="mt-3 sm:mt-0 sm:w-1/2 sm:pr-2">
                <button
                  type="button"
                  onClick={onClose}
                  disabled={isLoading}
                  className="w-full inline-flex justify-center rounded-md bg-slate-700 px-3 py-3 text-sm font-semibold text-white shadow-sm hover:bg-slate-600 transition-colors disabled:opacity-50"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default RefineModal;
```

### 📄 `Section.tsx`

**Path:** `components/Section.tsx`  
**Size:** 2 KB  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

interface SectionProps {
  title: string;
  children: React.ReactNode;
  onRefine?: () => void;
}

const SparklesIcon: React.FC<{className?: string}> = ({className}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className || "w-5 h-5"}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.572L16.5 21.75l-.398-1.178a3.375 3.375 0 00-2.455-2.456L12.75 18l1.178-.398a3.375 3.375 0 002.455-2.456L16.5 14.25l.398 1.178a3.375 3.375 0 002.456 2.456L20.25 18l-1.178.398a3.375 3.375 0 00-2.456 2.456z" />
  </svg>
);

const Section: React.FC<SectionProps> = ({ title, children, onRefine }) => {
  return (
    <div className="bg-slate-800/50 p-6 rounded-lg border border-slate-700">
      <div className="flex justify-between items-center border-b border-slate-600 pb-2 mb-4">
        <h2 className="text-xl font-semibold text-white">{title}</h2>
        {onRefine && (
           <button 
            type="button" 
            onClick={onRefine} 
            className="flex items-center gap-1.5 px-3 py-1 text-sm font-medium text-indigo-400 hover:text-indigo-300 hover:bg-indigo-900/20 rounded-md transition-all duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-800 focus-visible:ring-indigo-500"
            aria-label={`Refine ${title} section with AI`}
          >
            <SparklesIcon className="w-4 h-4" />
            Refine with AI
          </button>
        )}
      </div>
      <div className="space-y-4">
        {children}
      </div>
    </div>
  );
};

export default Section;
```

### 📄 `TextareaField.tsx`

**Path:** `components/TextareaField.tsx`  
**Size:** 893 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';

interface TextareaFieldProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  label: string;
  id: string;
  description?: string;
}

const TextareaField: React.FC<TextareaFieldProps> = ({ label, id, description, ...props }) => {
  return (
    <div>
      <label htmlFor={id} className="block text-sm font-medium text-slate-300">
        {label}
      </label>
      <div className="mt-1">
        <textarea
          id={id}
          rows={3}
          className="block w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded-md text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition"
          {...props}
        />
      </div>
      {description && <p className="mt-2 text-xs text-slate-500">{description}</p>}
    </div>
  );
};

export default TextareaField;
```

### 📄 `index.html`

**Path:** `index.html`  
**Size:** 2.7 KB  
**Language:** html (medium confidence)  
**Category:** Web Frontend  
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-g" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📝</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI PRD Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* For a custom scrollbar to match the dark theme */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      /* Styles for rendered markdown content */
      .markdown-content h1, .markdown-content h2, .markdown-content h3 {
        color: #f1f5f9; /* slate-100 */
      }
      .markdown-content h1 {
        font-size: 1.875rem; /* 3xl */
        font-weight: 800;
        margin-top: 2rem;
        margin-bottom: 1rem;
      }
      .markdown-content h2 {
        font-size: 1.5rem; /* 2xl */
        font-weight: 700;
        margin-top: 1.5rem;
        margin-bottom: 0.75rem;
        border-bottom: 1px solid #334155; /* slate-700 */
        padding-bottom: 0.5rem;
      }
      .markdown-content h3 {
        font-size: 1.25rem; /* xl */
        font-weight: 600;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      .markdown-content p {
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
        line-height: 1.625;
      }
      .markdown-content ul {
        list-style-type: disc;
        padding-left: 1.5rem;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .markdown-content li {
        margin-bottom: 0.25rem;
      }
      .markdown-content strong {
        color: #f8fafc; /* slate-50 */
        font-weight: 600;
      }
      .markdown-content em {
        font-style: italic;
      }
      .markdown-content hr {
        margin-top: 1.5rem;
        margin-bottom: 1.5rem;
        border-color: #334155; /* slate-700 */
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.16.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-900">
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
```

### 📄 `index.tsx`

**Path:** `index.tsx`  
**Size:** 351 B  
**Language:** tsx (medium confidence)  
**Category:** Web Frontend  
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

### 📄 `metadata.json`

**Path:** `metadata.json`  
**Size:** 206 B  
**Language:** json (medium confidence)  
**Category:** Data/Config  
```json
{
  "name": "PRD Creator",
  "description": "An AI-powered assistant to help you generate professional Product Requirements Documents (PRDs) by filling out a simple form.",
  "requestFramePermissions": []
}
```

### 📄 `package.json`

**Path:** `package.json`  
**Size:** 439 B  
**Language:** json (high confidence)  
**Category:** Data/Config  
```json
{
  "name": "prd-creator",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react-dom": "^19.1.1",
    "react": "^19.1.1",
    "@google/genai": "^1.16.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}
```

### 📄 `geminiService.ts`

**Path:** `services/geminiService.ts`  
**Size:** 9.2 KB  
**Language:** typescript (medium confidence)  
**Category:** Web Frontend  
```typescript
import { GoogleGenAI, Type } from "@google/genai";
import type { PRDInput } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const sectionFieldMapping: Record<string, (keyof PRDInput)[]> = {
  "1. Core Product Idea": ["productName", "problemStatement", "proposedSolution"],
  "2. Audience & Market": ["targetAudience", "businessGoals"],
  "3. Features & Scope": ["coreFeatures", "futureFeatures"],
  "4. Technical Details (Optional)": ["techStack", "constraints"],
};


export const refinePRDSection = async (
  currentInputs: PRDInput,
  sectionTitle: string,
  userFeedback: string
): Promise<Partial<PRDInput>> => {
  try {
    const fieldsToRefine = sectionFieldMapping[sectionTitle];
    if (!fieldsToRefine) {
      throw new Error(`Invalid section title for refinement: ${sectionTitle}`);
    }

    const currentSectionData: Partial<PRDInput> = {};
    fieldsToRefine.forEach(key => {
      currentSectionData[key] = currentInputs[key];
    });

    const prompt = `You are an expert product management assistant. A user wants to refine a specific section of their Product Requirements Document based on their feedback.

Current document state (for context only):
${JSON.stringify(currentInputs, null, 2)}

Section to Refine: "${sectionTitle}"
Current values in this section:
${JSON.stringify(currentSectionData, null, 2)}

User's Feedback for refinement: "${userFeedback}"

Your task is to update the values for the fields in the "${sectionTitle}" section based on the user's feedback. Maintain the existing tone and style. Return ONLY a JSON object containing the updated key-value pairs for the fields in this section. The keys must be: ${fieldsToRefine.join(', ')}. Do not include any other text or explanations.`;

    const responseSchemaProperties: Record<string, { type: Type.STRING, description?: string }> = {};
    fieldsToRefine.forEach(field => {
        responseSchemaProperties[field] = { type: Type.STRING };
    });

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: responseSchemaProperties,
        }
      }
    });

    const jsonString = response.text.trim();
    const parsed = JSON.parse(jsonString);

    const validatedResult: Partial<PRDInput> = {};
    for (const key of fieldsToRefine) {
        if (Object.prototype.hasOwnProperty.call(parsed, key)) {
            validatedResult[key] = parsed[key];
        }
    }
    return validatedResult;

  } catch (error) {
    console.error("Error refining PRD section:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to refine section data: ${error.message}.`);
    }
    throw new Error("An unknown error occurred while refining the section.");
  }
};


export const generatePRDInputs = async (idea: string): Promise<PRDInput> => {
  try {
    const prompt = `You are a brilliant product strategist. A user has provided a high-level product idea. Your task is to analyze this idea and break it down into the foundational components of a Product Requirements Document. Based on the idea, generate a plausible product name, identify a specific target audience, formulate a clear problem statement and a corresponding solution, brainstorm a few core features for an MVP, and suggest some potential business goals, future features, and a possible tech stack.

User's Idea: "${idea}"

Return the response as a JSON object that strictly adheres to the provided schema. For features, use bullet points within the string.`;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            productName: { type: Type.STRING, description: "A creative and fitting name for the product." },
            targetAudience: { type: Type.STRING, description: "A description of the primary user demographic." },
            problemStatement: { type: Type.STRING, description: "The core problem this product solves." },
            proposedSolution: { type: Type.STRING, description: "How the product solves the problem." },
            coreFeatures: { type: Type.STRING, description: "A bulleted list of essential MVP features." },
            businessGoals: { type: Type.STRING, description: "Key business objectives for the product." },
            futureFeatures: { type: Type.STRING, description: "A bulleted list of potential features for future releases." },
            techStack: { type: Type.STRING, description: "A suggested technology stack (e.g., React, Python, AWS)." },
            constraints: { type: Type.STRING, description: "Any potential constraints or dependencies to consider." },
          },
          required: [
            "productName",
            "targetAudience",
            "problemStatement",
            "proposedSolution",
            "coreFeatures",
          ]
        }
      }
    });

    const jsonString = response.text.trim();
    const parsed = JSON.parse(jsonString);

    // Ensure all fields are strings, even optional ones, to prevent issues with form state
    const result: PRDInput = {
      productName: parsed.productName || '',
      targetAudience: parsed.targetAudience || '',
      problemStatement: parsed.problemStatement || '',
      proposedSolution: parsed.proposedSolution || '',
      coreFeatures: parsed.coreFeatures || '',
      businessGoals: parsed.businessGoals || '',
      futureFeatures: parsed.futureFeatures || '',
      techStack: parsed.techStack || '',
      constraints: parsed.constraints || '',
    };

    return result;

  } catch (error) {
    console.error("Error generating PRD inputs:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to pre-fill form data: ${error.message}. Please try again.`);
    }
    throw new Error("An unknown error occurred while pre-filling the form. Please try again.");
  }
};


const generatePrompt = (inputs: PRDInput): string => {
  return `
You are an expert Senior Product Manager at a leading tech company. Your task is to write a comprehensive Product Requirements Document (PRD) based on the following information. The PRD should be well-structured, clear, professional, and detailed, suitable for a development team to start working from. Format the output in clean Markdown.

**Product Name:** ${inputs.productName}

---

### 1. Introduction & Vision

**1.1. Problem Statement**
*The core problem this product solves is:*
${inputs.problemStatement}

**1.2. Proposed Solution**
*Our proposed solution is:*
${inputs.proposedSolution}

**1.3. Vision**
*Based on the problem and solution, generate a compelling long-term vision for this product.*

---

### 2. Target Audience & User Personas

**2.1. Primary Audience**
*The primary users for this product are:*
${inputs.targetAudience}

**2.2. User Personas**
*Based on the target audience, generate 2-3 brief but distinct user personas. For each persona, include their goals and frustrations related to the problem statement.*

---

### 3. Product Goals & Success Metrics

**3.1. Business Goals**
*The key business objectives for this product are:*
${inputs.businessGoals || 'Not specified. Generate reasonable business goals like user acquisition, engagement, and revenue generation.'}

**3.2. Success Metrics (KPIs)**
*We will measure success through the following Key Performance Indicators:*
*Based on the business goals, generate specific, measurable, achievable, relevant, and time-bound (SMART) KPIs.*

---

### 4. Features & Requirements

**4.1. Core Features (MVP)**
*The essential features for the Minimum Viable Product are:*
${inputs.coreFeatures}

**4.2. User Stories**
*For each core feature listed above, write 2-3 detailed user stories in the format: "As a [user type], I want to [action], so that I can [benefit]."*

**4.3. Future Features (Post-MVP)**
*Potential features for future releases include:*
${inputs.futureFeatures || 'Not specified. Brainstorm 2-4 logical feature enhancements for future consideration.'}

---

### 5. Technical Considerations & Constraints

**5.1. Technology Stack**
*The proposed or existing technology stack is:*
${inputs.techStack || 'Not specified.'}

**5.2. Constraints & Dependencies**
*Known limitations and dependencies are:*
${inputs.constraints || 'None specified.'}

---

### 6. Out of Scope

*To ensure focus for the initial release, the following items are explicitly out of scope for the MVP:*
*Based on the core features, define what will NOT be included in the initial release to manage expectations.*
  `;
};

export const generatePRD = async (inputs: PRDInput): Promise<string> => {
  try {
    const prompt = generatePrompt(inputs);
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });
    
    return response.text;
  } catch (error) {
    console.error("Error generating PRD:", error);
    if (error instanceof Error) {
        return `An error occurred while generating the PRD: ${error.message}`;
    }
    return "An unknown error occurred while generating the PRD.";
  }
};
```

### 📄 `tsconfig.json`

**Path:** `tsconfig.json`  
**Size:** 542 B  
**Language:** json (high confidence)  
**Category:** Data/Config  
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
```

### 📄 `types.ts`

**Path:** `types.ts`  
**Size:** 255 B  
**Language:** typescript (medium confidence)  
**Category:** Web Frontend  
```typescript
export interface PRDInput {
  productName: string;
  targetAudience: string;
  problemStatement: string;
  proposedSolution: string;
  coreFeatures: string;
  businessGoals: string;
  futureFeatures: string;
  techStack: string;
  constraints: string;
}
```

### 📄 `vite.config.ts`

**Path:** `vite.config.ts`  
**Size:** 580 B  
**Language:** typescript (medium confidence)  
**Category:** Web Frontend  
```typescript
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});
```

---

### 📊 Processing Summary

- **Files Processed:** 21
- **Files Skipped:** 0
- **Total Files:** 21
- **Concurrency Limit:** 4
